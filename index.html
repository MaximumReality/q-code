<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Q-Code Restoration</title>
<style>
  :root { --neon-pink:#ff00ff; --neon-cyan:#00ffff; }
  body {
    margin:0; background:url('clean-poster.PNG') no-repeat center center fixed;
    background-size:cover; overflow:hidden; font-family:'Courier New', monospace;
  }
  #score-display {
    position:fixed; top:env(safe-area-inset-top, 20px); left:20px; font-size:1.8rem; 
    color:var(--neon-cyan); text-shadow:0 0 10px var(--neon-cyan); z-index: 100;
  }
  #hud-controls { position:fixed; top:env(safe-area-inset-top, 20px); right:20px; display:flex; gap:15px; z-index:10000; }
  .hud-btn { font-size:2rem; cursor:pointer; filter: drop-shadow(0 0 5px var(--neon-cyan)); }
  #p5-container { position: absolute; top: 0; left: 0; }
</style>
</head>
<body>

<div id="score-display">Score: 0</div>
<div id="hud-controls">
  <span class="hud-btn" onclick="goHome()">üè°</span>
  <span class="hud-btn" onclick="toggleMusic()">‚èØÔ∏è</span>
  <span class="hud-btn" id="mute-btn" onclick="toggleMute()">üîá</span>
</div>

<div id="p5-container"></div>

<audio id="bgMusic" src="a-sunny-day.mp3" loop preload="auto"></audio>
<audio id="hopSound" src="hop.wav" preload="auto"></audio>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
<script>
let levelsData = [6, 5, 4], currentLevel = 0, cubes = [], azul, azulTarget, popFrames = 0;
let azulCurses = ["@!#?@!", "??!!#", "#$%@!", "G-L-I-T-C-H"];
let score = 0;
let audioStarted = false;

const bgMusic = document.getElementById('bgMusic');
const hopSound = document.getElementById('hopSound');

function toggleMusic() { bgMusic.paused ? bgMusic.play() : bgMusic.pause(); }
function toggleMute() { bgMusic.muted = hopSound.muted = !bgMusic.muted; document.getElementById('mute-btn').innerText = bgMusic.muted ? "üîä" : "üîá"; }
function goHome() { window.location.href = "https://MaximumReality.xyz"; }

new p5((sketch) => {
  let cubeSize = 42; // Perfect scale for iPhone width
  let azulImg;

  sketch.preload = function() {
    azulImg = sketch.loadImage('azul-tactical.png');
  }

  sketch.setup = function() {
    sketch.createCanvas(sketch.windowWidth, sketch.windowHeight).parent('p5-container');
    setupPyramid();
  }

  sketch.draw = function() {
    sketch.clear();
    
    // Draw from back to front for correct 3D stacking
    for (let r = cubes.length - 1; r >= 0; r--) {
      for (let c = 0; c < cubes[r].length; c++) {
        drawIsoCube(cubes[r][c], sketch);
      }
    }

    // Azul Movement
    azul.x += (azulTarget.x - azul.x) * 0.2;
    azul.y += (azulTarget.y - azul.y) * 0.2;
    let hop = popFrames > 0 ? Math.sin(sketch.map(popFrames, 0, 10, 0, Math.PI)) * 15 : 0;

    sketch.imageMode(sketch.CENTER);
    sketch.image(azulImg, azul.x, azul.y - 25 - hop, 70, 70);

    if (popFrames > 0) popFrames--;

    // Floating Curses
    cubes.flat().forEach(cube => {
      if (cube.pop) {
        sketch.fill('#00ffff');
        sketch.textSize(20);
        sketch.text(sketch.random(azulCurses), cube.x, cube.y - 60 - (10 - popFrames));
        if (popFrames === 0) cube.pop = false;
      }
    });
  }

  sketch.mousePressed = function() {
    // FORCE AUDIO UNLOCK
    if (!audioStarted) {
      bgMusic.play();
      audioStarted = true;
    }

    for (let r = 0; r < cubes.length; r++) {
      for (let c = 0; c < cubes[r].length; c++) {
        let cube = cubes[r][c];
        // Optimized tap detection for mobile
        if (sketch.dist(sketch.mouseX, sketch.mouseY, cube.x, cube.y) < 35) {
          if (!cube.compiled) { score++; cube.compiled = true; }
          azulTarget.x = cube.x;
          azulTarget.y = cube.y;
          cube.pop = true;
          popFrames = 10;
          hopSound.currentTime = 0;
          hopSound.play();
          document.getElementById('score-display').textContent = 'Score: ' + score;
        }
      }
    }
  }

  function drawIsoCube(cube, s) {
    let x = cube.x, y = cube.y;
    let topC = cube.compiled ? s.color(0, 255, 255) : s.color(255, 0, 85);
    let leftC = cube.compiled ? s.color(0, 180, 180) : s.color(153, 0, 51);
    let rightC = cube.compiled ? s.color(0, 200, 200) : s.color(204, 0, 68);

    s.push();
    s.translate(x, y);
    s.noStroke();
    // Top
    s.fill(topC);
    s.quad(0, -cubeSize/2, cubeSize, -cubeSize/4, 0, 0, -cubeSize, -cubeSize/4);
    // Left
    s.fill(leftC);
    s.quad(-cubeSize, -cubeSize/4, 0, 0, 0, cubeSize/2, -cubeSize, cubeSize/4);
    // Right
    s.fill(rightC);
    s.quad(0, 0, cubeSize, -cubeSize/4, cubeSize, cubeSize/4, 0, cubeSize/2);
    s.pop();
  }

  function setupPyramid() {
    cubes = [];
    let lvl = levelsData[currentLevel];
    for (let i = lvl - 1; i >= 0; i--) {
      let row = [];
      for (let j = 0; j <= i; j++) {
        // Narrower spacing (cubeSize * 1.8) to fit iPhone screen
        let x = sketch.width / 2 + (j - i / 2) * (cubeSize * 1.8);
        let y = 250 + (lvl - i) * (cubeSize * 0.75);
        row.push({ x, y, compiled: false, pop: false });
      }
      cubes.push(row);
    }
    azul = { x: cubes[0][0].x, y: cubes[0][0].y };
    azulTarget = { ...azul };
  }
}, 'p5-container');
</script>
</body>
</html>
